{"ast":null,"code":"/* istanbul ignore file */\n\n/* tslint:disable */\n\n/* eslint-disable */\nimport axios from 'axios';\nimport FormData from 'form-data';\nimport { ApiError } from './ApiError';\nimport { CancelablePromise } from './CancelablePromise';\nimport { OpenAPI } from './OpenAPI';\n\nfunction isDefined(value) {\n  return value !== undefined && value !== null;\n}\n\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction isStringWithValue(value) {\n  return isString(value) && value !== '';\n}\n\nfunction isBlob(value) {\n  return typeof value === 'object' && typeof value.type === 'string' && typeof value.stream === 'function' && typeof value.arrayBuffer === 'function' && typeof value.constructor === 'function' && typeof value.constructor.name === 'string' && /^(Blob|File)$/.test(value.constructor.name) && /^(Blob|File)$/.test(value[Symbol.toStringTag]);\n}\n\nfunction isSuccess(status) {\n  return status >= 200 && status < 300;\n}\n\nfunction base64(str) {\n  try {\n    return btoa(str);\n  } catch (err) {\n    // @ts-ignore\n    return Buffer.from(str).toString('base64');\n  }\n}\n\nfunction getQueryString(params) {\n  const qs = [];\n\n  const append = (key, value) => {\n    qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);\n  };\n\n  Object.entries(params).filter(_ref => {\n    let [_, value] = _ref;\n    return isDefined(value);\n  }).forEach(_ref2 => {\n    let [key, value] = _ref2;\n\n    if (Array.isArray(value)) {\n      value.forEach(v => append(key, v));\n    } else {\n      append(key, value);\n    }\n  });\n\n  if (qs.length > 0) {\n    return `?${qs.join('&')}`;\n  }\n\n  return '';\n}\n\nfunction getUrl(options) {\n  const path = OpenAPI.ENCODE_PATH ? OpenAPI.ENCODE_PATH(options.path) : options.path;\n  const url = `${OpenAPI.BASE}${path}`;\n\n  if (options.query) {\n    return `${url}${getQueryString(options.query)}`;\n  }\n\n  return url;\n}\n\nfunction getFormData(options) {\n  if (options.formData) {\n    const formData = new FormData();\n\n    const append = (key, value) => {\n      if (isString(value) || isBlob(value)) {\n        formData.append(key, value);\n      } else {\n        formData.append(key, JSON.stringify(value));\n      }\n    };\n\n    Object.entries(options.formData).filter(_ref3 => {\n      let [_, value] = _ref3;\n      return isDefined(value);\n    }).forEach(_ref4 => {\n      let [key, value] = _ref4;\n\n      if (Array.isArray(value)) {\n        value.forEach(v => append(key, v));\n      } else {\n        append(key, value);\n      }\n    });\n    return formData;\n  }\n\n  return;\n}\n\nasync function resolve(options, resolver) {\n  if (typeof resolver === 'function') {\n    return resolver(options);\n  }\n\n  return resolver;\n}\n\nasync function getHeaders(options, formData) {\n  const token = await resolve(options, OpenAPI.TOKEN);\n  const username = await resolve(options, OpenAPI.USERNAME);\n  const password = await resolve(options, OpenAPI.PASSWORD);\n  const additionalHeaders = await resolve(options, OpenAPI.HEADERS);\n  const formHeaders = typeof (formData === null || formData === void 0 ? void 0 : formData.getHeaders) === 'function' && (formData === null || formData === void 0 ? void 0 : formData.getHeaders()) || {};\n  const headers = Object.entries({\n    Accept: 'application/json',\n    ...additionalHeaders,\n    ...options.headers,\n    ...formHeaders\n  }).filter(_ref5 => {\n    let [_, value] = _ref5;\n    return isDefined(value);\n  }).reduce((headers, _ref6) => {\n    let [key, value] = _ref6;\n    return { ...headers,\n      [key]: String(value)\n    };\n  }, {});\n\n  if (isStringWithValue(token)) {\n    headers['Authorization'] = `Bearer ${token}`;\n  }\n\n  if (isStringWithValue(username) && isStringWithValue(password)) {\n    const credentials = base64(`${username}:${password}`);\n    headers['Authorization'] = `Basic ${credentials}`;\n  }\n\n  return headers;\n}\n\nfunction getRequestBody(options) {\n  if (options.body) {\n    return options.body;\n  }\n\n  return;\n}\n\nasync function sendRequest(options, url, formData, body, headers, onCancel) {\n  const source = axios.CancelToken.source();\n  const config = {\n    url,\n    headers,\n    data: body || formData,\n    method: options.method,\n    withCredentials: OpenAPI.WITH_CREDENTIALS,\n    cancelToken: source.token\n  };\n  onCancel(() => source.cancel('The user aborted a request.'));\n\n  try {\n    return await axios.request(config);\n  } catch (error) {\n    const axiosError = error;\n\n    if (axiosError.response) {\n      return axiosError.response;\n    }\n\n    throw error;\n  }\n}\n\nfunction getResponseHeader(response, responseHeader) {\n  if (responseHeader) {\n    const content = response.headers[responseHeader];\n\n    if (isString(content)) {\n      return content;\n    }\n  }\n\n  return;\n}\n\nfunction getResponseBody(response) {\n  if (response.status !== 204) {\n    return response.data;\n  }\n\n  return;\n}\n\nfunction catchErrors(options, result) {\n  const errors = {\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    403: 'Forbidden',\n    404: 'Not Found',\n    500: 'Internal Server Error',\n    502: 'Bad Gateway',\n    503: 'Service Unavailable',\n    ...options.errors\n  };\n  const error = errors[result.status];\n\n  if (error) {\n    throw new ApiError(result, error);\n  }\n\n  if (!result.ok) {\n    throw new ApiError(result, 'Generic Error');\n  }\n}\n/**\n * Request using axios client\n * @param options The request options from the the service\n * @returns CancelablePromise<T>\n * @throws ApiError\n */\n\n\nexport function request(options) {\n  return new CancelablePromise(async (resolve, reject, onCancel) => {\n    try {\n      const url = getUrl(options);\n      const formData = getFormData(options);\n      const body = getRequestBody(options);\n      const headers = await getHeaders(options, formData);\n\n      if (!onCancel.isCancelled) {\n        const response = await sendRequest(options, url, formData, body, headers, onCancel);\n        const responseBody = getResponseBody(response);\n        const responseHeader = getResponseHeader(response, options.responseHeader);\n        const result = {\n          url,\n          ok: isSuccess(response.status),\n          status: response.status,\n          statusText: response.statusText,\n          body: responseHeader || responseBody\n        };\n        catchErrors(options, result);\n        resolve(result.body);\n      }\n    } catch (error) {\n      reject(error);\n    }\n  });\n}","map":{"version":3,"sources":["/Users/nikita/testProjectTabel/src/api-client-codegen/core/request.ts"],"names":["axios","FormData","ApiError","CancelablePromise","OpenAPI","isDefined","value","undefined","isString","isStringWithValue","isBlob","type","stream","arrayBuffer","constructor","name","test","Symbol","toStringTag","isSuccess","status","base64","str","btoa","err","Buffer","from","toString","getQueryString","params","qs","append","key","push","encodeURIComponent","String","Object","entries","filter","_","forEach","Array","isArray","v","length","join","getUrl","options","path","ENCODE_PATH","url","BASE","query","getFormData","formData","JSON","stringify","resolve","resolver","getHeaders","token","TOKEN","username","USERNAME","password","PASSWORD","additionalHeaders","HEADERS","formHeaders","headers","Accept","reduce","credentials","getRequestBody","body","sendRequest","onCancel","source","CancelToken","config","data","method","withCredentials","WITH_CREDENTIALS","cancelToken","cancel","request","error","axiosError","response","getResponseHeader","responseHeader","content","getResponseBody","catchErrors","result","errors","ok","reject","isCancelled","responseBody","statusText"],"mappings":"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","sourcesContent":["/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nimport axios, { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';\nimport FormData from 'form-data';\n\nimport { ApiError } from './ApiError';\nimport type { ApiRequestOptions } from './ApiRequestOptions';\nimport type { ApiResult } from './ApiResult';\nimport { CancelablePromise } from './CancelablePromise';\nimport type { OnCancel } from './CancelablePromise';\nimport { OpenAPI } from './OpenAPI';\n\nfunction isDefined<T>(value: T | null | undefined): value is Exclude<T, null | undefined> {\n    return value !== undefined && value !== null;\n}\n\nfunction isString(value: any): value is string {\n    return typeof value === 'string';\n}\n\nfunction isStringWithValue(value: any): value is string {\n    return isString(value) && value !== '';\n}\n\nfunction isBlob(value: any): value is Blob {\n    return (\n        typeof value === 'object' &&\n        typeof value.type === 'string' &&\n        typeof value.stream === 'function' &&\n        typeof value.arrayBuffer === 'function' &&\n        typeof value.constructor === 'function' &&\n        typeof value.constructor.name === 'string' &&\n        /^(Blob|File)$/.test(value.constructor.name) &&\n        /^(Blob|File)$/.test(value[Symbol.toStringTag])\n    );\n}\n\nfunction isSuccess(status: number): boolean {\n    return status >= 200 && status < 300;\n}\n\nfunction base64(str: string): string {\n    try {\n        return btoa(str);\n    } catch (err) {\n        // @ts-ignore\n        return Buffer.from(str).toString('base64');\n    }\n}\n\nfunction getQueryString(params: Record<string, any>): string {\n    const qs: string[] = [];\n\n    const append = (key: string, value: any) => {\n        qs.push(`${encodeURIComponent(key)}=${encodeURIComponent(String(value))}`);\n    };\n\n    Object.entries(params)\n        .filter(([_, value]) => isDefined(value))\n        .forEach(([key, value]) => {\n            if (Array.isArray(value)) {\n                value.forEach(v => append(key, v));\n            } else {\n                append(key, value);\n            }\n        });\n\n    if (qs.length > 0) {\n        return `?${qs.join('&')}`;\n    }\n\n    return '';\n}\n\nfunction getUrl(options: ApiRequestOptions): string {\n    const path = OpenAPI.ENCODE_PATH ? OpenAPI.ENCODE_PATH(options.path) : options.path;\n    const url = `${OpenAPI.BASE}${path}`;\n    if (options.query) {\n        return `${url}${getQueryString(options.query)}`;\n    }\n\n    return url;\n}\n\nfunction getFormData(options: ApiRequestOptions): FormData | undefined {\n    if (options.formData) {\n        const formData = new FormData();\n\n        const append = (key: string, value: any) => {\n            if (isString(value) || isBlob(value)) {\n                formData.append(key, value);\n            } else {\n                formData.append(key, JSON.stringify(value));\n            }\n        };\n\n        Object.entries(options.formData)\n            .filter(([_, value]) => isDefined(value))\n            .forEach(([key, value]) => {\n                if (Array.isArray(value)) {\n                    value.forEach(v => append(key, v));\n                } else {\n                    append(key, value);\n                }\n            });\n\n        return formData;\n    }\n    return;\n}\n\ntype Resolver<T> = (options: ApiRequestOptions) => Promise<T>;\n\nasync function resolve<T>(options: ApiRequestOptions, resolver?: T | Resolver<T>): Promise<T | undefined> {\n    if (typeof resolver === 'function') {\n        return (resolver as Resolver<T>)(options);\n    }\n    return resolver;\n}\n\nasync function getHeaders(options: ApiRequestOptions, formData?: FormData): Promise<Record<string, string>> {\n    const token = await resolve(options, OpenAPI.TOKEN);\n    const username = await resolve(options, OpenAPI.USERNAME);\n    const password = await resolve(options, OpenAPI.PASSWORD);\n    const additionalHeaders = await resolve(options, OpenAPI.HEADERS);\n    const formHeaders = typeof formData?.getHeaders === 'function' && formData?.getHeaders() || {}\n\n    const headers = Object.entries({\n        Accept: 'application/json',\n        ...additionalHeaders,\n        ...options.headers,\n        ...formHeaders,\n    })\n    .filter(([_, value]) => isDefined(value))\n    .reduce((headers, [key, value]) => ({\n        ...headers,\n        [key]: String(value),\n    }), {} as Record<string, string>);\n\n    if (isStringWithValue(token)) {\n        headers['Authorization'] = `Bearer ${token}`;\n    }\n\n    if (isStringWithValue(username) && isStringWithValue(password)) {\n        const credentials = base64(`${username}:${password}`);\n        headers['Authorization'] = `Basic ${credentials}`;\n    }\n\n    return headers;\n}\n\nfunction getRequestBody(options: ApiRequestOptions): any {\n    if (options.body) {\n        return options.body;\n    }\n    return;\n}\n\nasync function sendRequest(\n    options: ApiRequestOptions,\n    url: string,\n    formData: FormData | undefined,\n    body: any,\n    headers: Record<string, string>,\n    onCancel: OnCancel\n): Promise<AxiosResponse<any>> {\n    const source = axios.CancelToken.source();\n\n    const config: AxiosRequestConfig = {\n        url,\n        headers,\n        data: body || formData,\n        method: options.method,\n        withCredentials: OpenAPI.WITH_CREDENTIALS,\n        cancelToken: source.token,\n    };\n\n    onCancel(() => source.cancel('The user aborted a request.'));\n\n    try {\n        return await axios.request(config);\n    } catch (error) {\n        const axiosError = error as AxiosError;\n        if (axiosError.response) {\n            return axiosError.response;\n        }\n        throw error;\n    }\n}\n\nfunction getResponseHeader(response: AxiosResponse<any>, responseHeader?: string): string | undefined {\n    if (responseHeader) {\n        const content = response.headers[responseHeader];\n        if (isString(content)) {\n            return content;\n        }\n    }\n    return;\n}\n\nfunction getResponseBody(response: AxiosResponse<any>): any {\n    if (response.status !== 204) {\n        return response.data;\n    }\n    return;\n}\n\nfunction catchErrors(options: ApiRequestOptions, result: ApiResult): void {\n    const errors: Record<number, string> = {\n        400: 'Bad Request',\n        401: 'Unauthorized',\n        403: 'Forbidden',\n        404: 'Not Found',\n        500: 'Internal Server Error',\n        502: 'Bad Gateway',\n        503: 'Service Unavailable',\n        ...options.errors,\n    }\n\n    const error = errors[result.status];\n    if (error) {\n        throw new ApiError(result, error);\n    }\n\n    if (!result.ok) {\n        throw new ApiError(result, 'Generic Error');\n    }\n}\n\n/**\n * Request using axios client\n * @param options The request options from the the service\n * @returns CancelablePromise<T>\n * @throws ApiError\n */\nexport function request<T>(options: ApiRequestOptions): CancelablePromise<T> {\n    return new CancelablePromise(async (resolve, reject, onCancel) => {\n        try {\n            const url = getUrl(options);\n            const formData = getFormData(options);\n            const body = getRequestBody(options);\n            const headers = await getHeaders(options, formData);\n\n            if (!onCancel.isCancelled) {\n                const response = await sendRequest(options, url, formData, body, headers, onCancel);\n                const responseBody = getResponseBody(response);\n                const responseHeader = getResponseHeader(response, options.responseHeader);\n\n                const result: ApiResult = {\n                    url,\n                    ok: isSuccess(response.status),\n                    status: response.status,\n                    statusText: response.statusText,\n                    body: responseHeader || responseBody,\n                };\n\n                catchErrors(options, result);\n\n                resolve(result.body);\n            }\n        } catch (error) {\n            reject(error);\n        }\n    });\n}"]},"metadata":{},"sourceType":"module"}