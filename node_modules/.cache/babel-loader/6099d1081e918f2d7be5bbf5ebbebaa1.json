{"ast":null,"code":"import _classPrivateFieldLooseBase from \"/Users/nikita/testProjectTabel/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";\nimport _classPrivateFieldLooseKey from \"/Users/nikita/testProjectTabel/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";\n\nlet _Symbol$toStringTag;\n\n/* istanbul ignore file */\n\n/* tslint:disable */\n\n/* eslint-disable */\nexport class CancelError extends Error {\n  constructor() {\n    let reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Promise was canceled';\n    super(reason);\n    this.name = 'CancelError';\n  }\n\n  get isCancelled() {\n    return true;\n  }\n\n}\n\nvar _isPending = /*#__PURE__*/_classPrivateFieldLooseKey(\"isPending\");\n\nvar _isCancelled = /*#__PURE__*/_classPrivateFieldLooseKey(\"isCancelled\");\n\nvar _cancelHandlers = /*#__PURE__*/_classPrivateFieldLooseKey(\"cancelHandlers\");\n\nvar _promise = /*#__PURE__*/_classPrivateFieldLooseKey(\"promise\");\n\nvar _resolve = /*#__PURE__*/_classPrivateFieldLooseKey(\"resolve\");\n\nvar _reject = /*#__PURE__*/_classPrivateFieldLooseKey(\"reject\");\n\n_Symbol$toStringTag = Symbol.toStringTag;\nexport class CancelablePromise {\n  constructor(executor) {\n    this[_Symbol$toStringTag] = void 0;\n    Object.defineProperty(this, _isPending, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _isCancelled, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _cancelHandlers, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _promise, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _resolve, {\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, _reject, {\n      writable: true,\n      value: void 0\n    });\n    _classPrivateFieldLooseBase(this, _isPending)[_isPending] = true;\n    _classPrivateFieldLooseBase(this, _isCancelled)[_isCancelled] = false;\n    _classPrivateFieldLooseBase(this, _cancelHandlers)[_cancelHandlers] = [];\n    _classPrivateFieldLooseBase(this, _promise)[_promise] = new Promise((resolve, reject) => {\n      _classPrivateFieldLooseBase(this, _resolve)[_resolve] = resolve;\n      _classPrivateFieldLooseBase(this, _reject)[_reject] = reject;\n\n      const onResolve = value => {\n        if (!_classPrivateFieldLooseBase(this, _isCancelled)[_isCancelled]) {\n          var _classPrivateFieldLoo, _classPrivateFieldLoo2;\n\n          _classPrivateFieldLooseBase(this, _isPending)[_isPending] = false;\n          (_classPrivateFieldLoo = (_classPrivateFieldLoo2 = _classPrivateFieldLooseBase(this, _resolve))[_resolve]) === null || _classPrivateFieldLoo === void 0 ? void 0 : _classPrivateFieldLoo.call(_classPrivateFieldLoo2, value);\n        }\n      };\n\n      const onReject = reason => {\n        var _classPrivateFieldLoo3, _classPrivateFieldLoo4;\n\n        _classPrivateFieldLooseBase(this, _isPending)[_isPending] = false;\n        (_classPrivateFieldLoo3 = (_classPrivateFieldLoo4 = _classPrivateFieldLooseBase(this, _reject))[_reject]) === null || _classPrivateFieldLoo3 === void 0 ? void 0 : _classPrivateFieldLoo3.call(_classPrivateFieldLoo4, reason);\n      };\n\n      const onCancel = cancelHandler => {\n        if (_classPrivateFieldLooseBase(this, _isPending)[_isPending]) {\n          _classPrivateFieldLooseBase(this, _cancelHandlers)[_cancelHandlers].push(cancelHandler);\n        }\n      };\n\n      Object.defineProperty(onCancel, 'isPending', {\n        get: () => _classPrivateFieldLooseBase(this, _isPending)[_isPending]\n      });\n      Object.defineProperty(onCancel, 'isCancelled', {\n        get: () => _classPrivateFieldLooseBase(this, _isCancelled)[_isCancelled]\n      });\n      return executor(onResolve, onReject, onCancel);\n    });\n  }\n\n  then(onFulfilled, onRejected) {\n    return _classPrivateFieldLooseBase(this, _promise)[_promise].then(onFulfilled, onRejected);\n  }\n\n  catch(onRejected) {\n    return _classPrivateFieldLooseBase(this, _promise)[_promise].catch(onRejected);\n  }\n\n  finally(onFinally) {\n    return _classPrivateFieldLooseBase(this, _promise)[_promise].finally(onFinally);\n  }\n\n  cancel() {\n    if (!_classPrivateFieldLooseBase(this, _isPending)[_isPending] || _classPrivateFieldLooseBase(this, _isCancelled)[_isCancelled]) {\n      return;\n    }\n\n    _classPrivateFieldLooseBase(this, _isCancelled)[_isCancelled] = true;\n\n    if (_classPrivateFieldLooseBase(this, _cancelHandlers)[_cancelHandlers].length) {\n      try {\n        for (const cancelHandler of _classPrivateFieldLooseBase(this, _cancelHandlers)[_cancelHandlers]) {\n          cancelHandler();\n        }\n      } catch (error) {\n        var _classPrivateFieldLoo5, _classPrivateFieldLoo6;\n\n        (_classPrivateFieldLoo5 = (_classPrivateFieldLoo6 = _classPrivateFieldLooseBase(this, _reject))[_reject]) === null || _classPrivateFieldLoo5 === void 0 ? void 0 : _classPrivateFieldLoo5.call(_classPrivateFieldLoo6, error);\n        return;\n      }\n    }\n  }\n\n  get isCancelled() {\n    return _classPrivateFieldLooseBase(this, _isCancelled)[_isCancelled];\n  }\n\n}","map":{"version":3,"sources":["/Users/nikita/testProjectTabel/src/api-client-codegen/core/CancelablePromise.ts"],"names":["CancelError","Error","constructor","reason","name","isCancelled","Symbol","toStringTag","CancelablePromise","executor","Promise","resolve","reject","onResolve","value","onReject","onCancel","cancelHandler","push","Object","defineProperty","get","then","onFulfilled","onRejected","catch","finally","onFinally","cancel","length","error"],"mappings":";;;;;AAAA;;AACA;;AACA;AACA,OAAO,MAAMA,WAAN,SAA0BC,KAA1B,CAAgC;AAEnCC,EAAAA,WAAW,GAA0C;AAAA,QAAzCC,MAAyC,uEAAxB,sBAAwB;AACjD,UAAMA,MAAN;AACA,SAAKC,IAAL,GAAY,aAAZ;AACH;;AAEqB,MAAXC,WAAW,GAAY;AAC9B,WAAO,IAAP;AACH;;AATkC;;;;;;;;;;;;;;sBAoBzBC,MAAM,CAACC,W;AADrB,OAAO,MAAMC,iBAAN,CAAiD;AAUpDN,EAAAA,WAAW,CACPO,QADO,EAMT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACE,gEAAkB,IAAlB;AACA,oEAAoB,KAApB;AACA,0EAAuB,EAAvB;AACA,4DAAgB,IAAIC,OAAJ,CAAe,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAChD,8DAAgBD,OAAhB;AACA,4DAAeC,MAAf;;AAEA,YAAMC,SAAS,GAAIC,KAAD,IAAqC;AACnD,YAAI,6BAAC,IAAD,6BAAJ,EAAwB;AAAA;;AACpB,sEAAkB,KAAlB;AACA,gOAAgBA,KAAhB;AACH;AACJ,OALD;;AAOA,YAAMC,QAAQ,GAAIZ,MAAD,IAAwB;AAAA;;AACrC,oEAAkB,KAAlB;AACA,+NAAeA,MAAf;AACH,OAHD;;AAKA,YAAMa,QAAQ,GAAIC,aAAD,IAAqC;AAClD,wCAAI,IAAJ,2BAAqB;AACjB,8EAAqBC,IAArB,CAA0BD,aAA1B;AACH;AACJ,OAJD;;AAMAE,MAAAA,MAAM,CAACC,cAAP,CAAsBJ,QAAtB,EAAgC,WAAhC,EAA6C;AACzCK,QAAAA,GAAG,EAAE,kCAAe,IAAf;AADoC,OAA7C;AAIAF,MAAAA,MAAM,CAACC,cAAP,CAAsBJ,QAAtB,EAAgC,aAAhC,EAA+C;AAC3CK,QAAAA,GAAG,EAAE,kCAAe,IAAf;AADsC,OAA/C;AAIA,aAAOZ,QAAQ,CAACI,SAAD,EAAYE,QAAZ,EAAsBC,QAAtB,CAAf;AACH,KA/Be,CAAhB;AAgCH;;AAEMM,EAAAA,IAAI,CACPC,WADO,EAEPC,UAFO,EAGqB;AAC5B,WAAO,sDAAcF,IAAd,CAAmBC,WAAnB,EAAgCC,UAAhC,CAAP;AACH;;AAEMC,EAAAA,KAAK,CACRD,UADQ,EAEY;AACpB,WAAO,sDAAcC,KAAd,CAAoBD,UAApB,CAAP;AACH;;AAEME,EAAAA,OAAO,CAACC,SAAD,EAA8C;AACxD,WAAO,sDAAcD,OAAd,CAAsBC,SAAtB,CAAP;AACH;;AAEMC,EAAAA,MAAM,GAAS;AAClB,QAAI,6BAAC,IAAD,yDAAoB,IAApB,6BAAJ,EAA2C;AACvC;AACH;;AACD,oEAAoB,IAApB;;AACA,QAAI,oEAAqBC,MAAzB,EAAiC;AAC7B,UAAI;AACA,aAAK,MAAMZ,aAAX,gCAA4B,IAA5B,qCAAkD;AAC9CA,UAAAA,aAAa;AAChB;AACJ,OAJD,CAIE,OAAOa,KAAP,EAAc;AAAA;;AACZ,+NAAeA,KAAf;AACA;AACH;AACJ;AACJ;;AAEqB,MAAXzB,WAAW,GAAY;AAC9B,uCAAO,IAAP;AACH;;AA1FmD","sourcesContent":["/* istanbul ignore file */\n/* tslint:disable */\n/* eslint-disable */\nexport class CancelError extends Error {\n\n    constructor(reason: string = 'Promise was canceled') {\n        super(reason);\n        this.name = 'CancelError';\n    }\n\n    public get isCancelled(): boolean {\n        return true;\n    }\n}\n\nexport interface OnCancel {\n    readonly isPending: boolean;\n    readonly isCancelled: boolean;\n\n    (cancelHandler: () => void): void;\n}\n\nexport class CancelablePromise<T> implements Promise<T> {\n    readonly [Symbol.toStringTag]: string;\n\n    #isPending: boolean;\n    #isCancelled: boolean;\n    readonly #cancelHandlers: (() => void)[];\n    readonly #promise: Promise<T>;\n    #resolve?: (value: T | PromiseLike<T>) => void;\n    #reject?: (reason?: any) => void;\n\n    constructor(\n        executor: (\n            resolve: (value: T | PromiseLike<T>) => void,\n            reject: (reason?: any) => void,\n            onCancel: OnCancel\n        ) => void\n    ) {\n        this.#isPending = true;\n        this.#isCancelled = false;\n        this.#cancelHandlers = [];\n        this.#promise = new Promise<T>((resolve, reject) => {\n            this.#resolve = resolve;\n            this.#reject = reject;\n\n            const onResolve = (value: T | PromiseLike<T>): void => {\n                if (!this.#isCancelled) {\n                    this.#isPending = false;\n                    this.#resolve?.(value);\n                }\n            };\n\n            const onReject = (reason?: any): void => {\n                this.#isPending = false;\n                this.#reject?.(reason);\n            };\n\n            const onCancel = (cancelHandler: () => void): void => {\n                if (this.#isPending) {\n                    this.#cancelHandlers.push(cancelHandler);\n                }\n            };\n\n            Object.defineProperty(onCancel, 'isPending', {\n                get: (): boolean => this.#isPending,\n            });\n\n            Object.defineProperty(onCancel, 'isCancelled', {\n                get: (): boolean => this.#isCancelled,\n            });\n\n            return executor(onResolve, onReject, onCancel as OnCancel);\n        });\n    }\n\n    public then<TResult1 = T, TResult2 = never>(\n        onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,\n        onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null\n    ): Promise<TResult1 | TResult2> {\n        return this.#promise.then(onFulfilled, onRejected);\n    }\n\n    public catch<TResult = never>(\n        onRejected?: ((reason: any) => TResult | PromiseLike<TResult>) | null\n    ): Promise<T | TResult> {\n        return this.#promise.catch(onRejected);\n    }\n\n    public finally(onFinally?: (() => void) | null): Promise<T> {\n        return this.#promise.finally(onFinally);\n    }\n\n    public cancel(): void {\n        if (!this.#isPending || this.#isCancelled) {\n            return;\n        }\n        this.#isCancelled = true;\n        if (this.#cancelHandlers.length) {\n            try {\n                for (const cancelHandler of this.#cancelHandlers) {\n                    cancelHandler();\n                }\n            } catch (error) {\n                this.#reject?.(error);\n                return;\n            }\n        }\n    }\n\n    public get isCancelled(): boolean {\n        return this.#isCancelled;\n    }\n}"]},"metadata":{},"sourceType":"module"}